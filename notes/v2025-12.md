Backlog for Version 2025.12
===========================

Tracking of tasks and features planned for the 2025.12 release.



Playback Replays
----------------

Add support for playback replays in the game engine.

[x] Implement initial support for developers to load and play back replays.



Checkpoints in chipplay
-----------------------

Add a runtime checkpoint system for chipplay that makes long or difficult levels less punishing without modifying base level files.
During a run, the player should be able to create checkpoints. These checkpoints live only while playing and can be resumed at any time during play.

Resuming from a checkpoint must mark the run as checkpoint-assisted so progression rules stay fair.
Players should be allowed to finish the level, but record and trophy updates should be disabled for runs that used checkpoints.

Checkpoints should be easy to manage during play, with clear UI for creating and resuming.
The system should feel like a quality-of-life improvement that encourages experimentation without trivializing the challenge of completing levels.

[x] Initial checkpoint save and load system implemented.\
[x] Disable records and trophies for checkpoint-assisted runs.\
[ ] Improve the UX when a level is completed with checkpoints used.



Trap semantics
--------------

This change updates trap behavior and reintroduces momentum for entities that enter traps while sliding or on force floors.
When a trap is opened, it remains open until the entity leaves the trap tile; it does not close again while the entity is still inside.

Entities that enter a trap from ice or force floors retain both their facing direction and their movement momentum while in the trap.
When released, they are forced out of the trap in the same direction they were facing when they entered, regardless of any subsequent input.

Entities that were not forced into the trap via ice or force floors do not preserve any special momentum.
When such an entity is released from the trap, it can move out in any valid direction, based on normal player input or AI behavior.

[x] Reintroduce momentum for all entities entering traps from ice or force floors.\
[x] Blocks can be moved off traps once their button is pressed once.\

It all seems to work but is hacked together, Ideally the trap code should run independently of the other terrain interaction code.

[x] Refactor trap logic so released entities are never trapped.\
[x] Fix replays broken by this change.\



Explicit gameplay phases
------------------------

In some levels, the order in which monsters spawn affects gameplay significantly.
I would prefer this not to be the case, but fixing this is a slow and difficult process.

Implement gameplay in three distinct phases:

1. Process all entity movement
2. Process all entity actions (killing player, pickup items)
3. Process all terrain effects (traps, buttons; water, fire hazards for monsters)

[x] Refactor game loop to have explicit phases for movement, actions, terrain effects.\
[x] Split physics code into separate movement and terrain effect functions.\
[x] Fix broken replays after this change.

This doesn't resolve all issues, but it should help a lot.
In particular, movement order and collisions can still interact in an order-dependent way, so also:

[ ] Visualize monster order in the editor, with a little number next to each monster indicating its spawn order.\
[ ] Allow reordering monsters in the editor by dragging these numbers up and down.



Player Chip Clones
------------------

Allow creating multiple Player entities.

These Player entities all respond to the same input commands.
When a single Player entity dies, the game is over. When any Player entity reaches the exit, the level is won.

This requires moving the player control logic out of the single Chip entity and into the PlayerState so multiple Chips can respond to the same commands.
Each Chip should be independently affected by terrain and hazards, creating interesting puzzles that require coordinating several Chips at once.

Player inventory and stats are shared between player Chips, so collecting keys or items with one Chip benefits all controlled Chips.
Player chips are solid and cannot pass through each other, implement using block push logic.
Camera should focus on the 'master' player Chip, to keep the camera logic simple.

Monsters like Teeth should focus on the nearest player or mirror Chip, TBD what happens if multiple Chips are equidistant.

[x] Update player chasing logic to target the nearest player or mirror Chip.\
[x] Move forced_move flag to player entity flags.\
[x] Refactor game logic to support multiple player Chips.\
[x] Introduce the master player Chip and adjust win/lose conditions.\
[ ] Test with levels designed for multiple player Chips.\



Editor Save Replay
------------------

After a level is completed inside the editor, prompt the creator to save the replay.
If they accept, embed the replay data directly into the level file.
That run becomes the Author Trophy and as a verification that the level is solvable.

[x] Initial implementation.



Jump into gameplay from editor
------------------------------

Allow chipedit to start a play session for the currently open level using the same simulation and rendering pipeline as chipplay.
The editor’s level representation needs a reliable path into gameplay, so a test run behaves exactly like campaign play.
Gameplay in this mode should reuse the standard input handling and Fx/Play event pipeline instead of inventing a separate “editor” simulation.

Introduce a clean state transition between editor and a test-play sub-mode so the player can move back and forth without losing their place.
When a test run ends through death, victory, or user abort, control returns to the editor with camera, selection, and other editor state restored.
From a user perspective this should feel like a quick “Play from here” loop, not a separate application.

[x] Initial implementation of editor play mode.\
[x] Support controllers in editor play mode.\
[x] Add sound effects and music to editor play mode.\
[ ] Implement Scout and Pause functionality in editor play mode.



Structural level operations
---------------------------

Add structural tools that let the editor expand and shrink the rectangular playfield without manual data surgery.
Expansion should let the user choose which edges to grow and what default terrain or contents fill the new area, so options like “add wall border” or “empty floor” are possible.
Shrinking should remove rows or columns at the edges but must consider what happens to entities that would fall outside the new bounds.

Make sure the underlying level and field representations stay flexible and can handle resizing without corrupting data.
Integrate these operations into the editor as menus or dialogs that use the new UI infrastructure, giving users a straightforward “Resize field” entry point.
The overall feel should be closer to resizing a canvas in an image editor than editing raw dimensions.

[x] Fix glitchy resize behavior when shrinking levels.\
[x] Fix crash when resizing to zero width/height.\
[x] Implement level expansion and shrinking in terms of `LevelBrush`.\

### Selection, move/copy, and fill

Introduce a selection mode for rectangular regions so users can manipulate areas instead of single tiles.
Click-drag should define a rectangle with a clear visual highlight, and there should be simple ways to cancel or adjust the selection.
Once a region is selected, tools can operate on it as a unit instead of requiring repetitive single-tile edits.

On top of selection, support moving and copying blocks of terrain and entities, with defined rules when pasted areas overlap existing content.
Add a terrain flood-fill tool to quickly change connected regions, making large-scale terrain adjustments practical.

[x] Introduce `LevelBrush` to paste level chunks.\
[x] Flood fill terrain tool.\



UI/menu infrastructure refactor
-------------------------------

Refactor the shared game/editor menus into a cleaner UI system so custom UIs are easy to define, compose, and reuse.
Clarify and extend the `chipgame::menu` stack model, and make the relationship between editor overlays and world rendering explicit.
This may include a simple layout abstraction for sidebars and overlays, so new UI panels don’t require bespoke layout hacks.

### Editor UI rework and tool palette

Replace in-world templates with a menu-driven tool palette that feels like a proper toolbox.
The palette should support browsable categories such as terrain, entities, and templates, and show visual previews in a side panel or overlay.
Common tools and elements should have shortcut keys so experienced users can work quickly without excessive menu diving.

Build the palette on top of the refactored menu system by defining a palette menu type that supports scrolling lists, icons, and selection callbacks.
Palette selection should feed directly into the editor’s paint tools so choosing an item updates the active brush, with feedback such as a highlighted tool or ghost tile under the cursor.
This shifts the editor from “place from weird in-world objects” to a more standard, discoverable tool-based workflow.
